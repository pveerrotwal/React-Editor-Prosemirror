{"ast":null,"code":"import { Schema } from 'prosemirror-model';\nvar pDOM = [\"p\", 0],\n    blockquoteDOM = [\"blockquote\", 0],\n    hrDOM = [\"hr\"],\n    preDOM = [\"pre\", [\"code\", 0]],\n    brDOM = [\"br\"]; // :: Object\n// [Specs](#model.NodeSpec) for the nodes defined in this schema.\n\nvar nodes = {\n  // :: NodeSpec The top level document node.\n  doc: {\n    content: \"block+\"\n  },\n  // :: NodeSpec A plain paragraph textblock. Represented in the DOM\n  // as a `<p>` element.\n  paragraph: {\n    content: \"inline*\",\n    group: \"block\",\n    parseDOM: [{\n      tag: \"p\"\n    }],\n    toDOM: function toDOM() {\n      return pDOM;\n    }\n  },\n  // :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.\n  blockquote: {\n    content: \"block+\",\n    group: \"block\",\n    defining: true,\n    parseDOM: [{\n      tag: \"blockquote\"\n    }],\n    toDOM: function toDOM() {\n      return blockquoteDOM;\n    }\n  },\n  // :: NodeSpec A horizontal rule (`<hr>`).\n  horizontal_rule: {\n    group: \"block\",\n    parseDOM: [{\n      tag: \"hr\"\n    }],\n    toDOM: function toDOM() {\n      return hrDOM;\n    }\n  },\n  // :: NodeSpec A heading textblock, with a `level` attribute that\n  // should hold the number 1 to 6. Parsed and serialized as `<h1>` to\n  // `<h6>` elements.\n  heading: {\n    attrs: {\n      level: {\n        default: 1\n      }\n    },\n    content: \"inline*\",\n    group: \"block\",\n    defining: true,\n    parseDOM: [{\n      tag: \"h1\",\n      attrs: {\n        level: 1\n      }\n    }, {\n      tag: \"h2\",\n      attrs: {\n        level: 2\n      }\n    }, {\n      tag: \"h3\",\n      attrs: {\n        level: 3\n      }\n    }, {\n      tag: \"h4\",\n      attrs: {\n        level: 4\n      }\n    }, {\n      tag: \"h5\",\n      attrs: {\n        level: 5\n      }\n    }, {\n      tag: \"h6\",\n      attrs: {\n        level: 6\n      }\n    }],\n    toDOM: function toDOM(node) {\n      return [\"h\" + node.attrs.level, 0];\n    }\n  },\n  // :: NodeSpec A code listing. Disallows marks or non-text inline\n  // nodes by default. Represented as a `<pre>` element with a\n  // `<code>` element inside of it.\n  code_block: {\n    content: \"text*\",\n    marks: \"\",\n    group: \"block\",\n    code: true,\n    defining: true,\n    parseDOM: [{\n      tag: \"pre\",\n      preserveWhitespace: \"full\"\n    }],\n    toDOM: function toDOM() {\n      return preDOM;\n    }\n  },\n  // :: NodeSpec The text node.\n  text: {\n    group: \"inline\"\n  },\n  // :: NodeSpec An inline image (`<img>`) node. Supports `src`,\n  // `alt`, and `href` attributes. The latter two default to the empty\n  // string.\n  image: {\n    inline: true,\n    attrs: {\n      src: {},\n      alt: {\n        default: null\n      },\n      title: {\n        default: null\n      }\n    },\n    group: \"inline\",\n    draggable: true,\n    parseDOM: [{\n      tag: \"img[src]\",\n      getAttrs: function getAttrs(dom) {\n        return {\n          src: dom.getAttribute(\"src\"),\n          title: dom.getAttribute(\"title\"),\n          alt: dom.getAttribute(\"alt\")\n        };\n      }\n    }],\n    toDOM: function toDOM(node) {\n      var ref = node.attrs;\n      var src = ref.src;\n      var alt = ref.alt;\n      var title = ref.title;\n      return [\"img\", {\n        src: src,\n        alt: alt,\n        title: title\n      }];\n    }\n  },\n  // :: NodeSpec A hard line break, represented in the DOM as `<br>`.\n  hard_break: {\n    inline: true,\n    group: \"inline\",\n    selectable: false,\n    parseDOM: [{\n      tag: \"br\"\n    }],\n    toDOM: function toDOM() {\n      return brDOM;\n    }\n  }\n};\nvar emDOM = [\"em\", 0],\n    strongDOM = [\"strong\", 0],\n    codeDOM = [\"code\", 0]; // :: Object [Specs](#model.MarkSpec) for the marks in the schema.\n\nvar marks = {\n  // :: MarkSpec A link. Has `href` and `title` attributes. `title`\n  // defaults to the empty string. Rendered and parsed as an `<a>`\n  // element.\n  link: {\n    attrs: {\n      href: {},\n      title: {\n        default: null\n      }\n    },\n    inclusive: false,\n    parseDOM: [{\n      tag: \"a[href]\",\n      getAttrs: function getAttrs(dom) {\n        return {\n          href: dom.getAttribute(\"href\"),\n          title: dom.getAttribute(\"title\")\n        };\n      }\n    }],\n    toDOM: function toDOM(node) {\n      var ref = node.attrs;\n      var href = ref.href;\n      var title = ref.title;\n      return [\"a\", {\n        href: href,\n        title: title\n      }, 0];\n    }\n  },\n  // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.\n  // Has parse rules that also match `<i>` and `font-style: italic`.\n  em: {\n    parseDOM: [{\n      tag: \"i\"\n    }, {\n      tag: \"em\"\n    }, {\n      style: \"font-style=italic\"\n    }],\n    toDOM: function toDOM() {\n      return emDOM;\n    }\n  },\n  // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules\n  // also match `<b>` and `font-weight: bold`.\n  strong: {\n    parseDOM: [{\n      tag: \"strong\"\n    }, // This works around a Google Docs misbehavior where\n    // pasted content will be inexplicably wrapped in `<b>`\n    // tags with a font-weight normal.\n    {\n      tag: \"b\",\n      getAttrs: function (node) {\n        return node.style.fontWeight != \"normal\" && null;\n      }\n    }, {\n      style: \"font-weight\",\n      getAttrs: function (value) {\n        return /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null;\n      }\n    }],\n    toDOM: function toDOM() {\n      return strongDOM;\n    }\n  },\n  // :: MarkSpec Code font mark. Represented as a `<code>` element.\n  code: {\n    parseDOM: [{\n      tag: \"code\"\n    }],\n    toDOM: function toDOM() {\n      return codeDOM;\n    }\n  }\n}; // :: Schema\n// This schema roughly corresponds to the document schema used by\n// [CommonMark](http://commonmark.org/), minus the list elements,\n// which are defined in the [`prosemirror-schema-list`](#schema-list)\n// module.\n//\n// To reuse elements from this schema, extend or read from its\n// `spec.nodes` and `spec.marks` [properties](#model.Schema.spec).\n\nvar schema = new Schema({\n  nodes: nodes,\n  marks: marks\n});\nexport { marks, nodes, schema };","map":{"version":3,"sources":["../src/schema-basic.js"],"names":["const"],"mappings":"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","sourcesContent":["import {Schema} from \"prosemirror-model\"\n\nconst pDOM = [\"p\", 0], blockquoteDOM = [\"blockquote\", 0], hrDOM = [\"hr\"],\n      preDOM = [\"pre\", [\"code\", 0]], brDOM = [\"br\"]\n\n// :: Object\n// [Specs](#model.NodeSpec) for the nodes defined in this schema.\nexport const nodes = {\n  // :: NodeSpec The top level document node.\n  doc: {\n    content: \"block+\"\n  },\n\n  // :: NodeSpec A plain paragraph textblock. Represented in the DOM\n  // as a `<p>` element.\n  paragraph: {\n    content: \"inline*\",\n    group: \"block\",\n    parseDOM: [{tag: \"p\"}],\n    toDOM() { return pDOM }\n  },\n\n  // :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.\n  blockquote: {\n    content: \"block+\",\n    group: \"block\",\n    defining: true,\n    parseDOM: [{tag: \"blockquote\"}],\n    toDOM() { return blockquoteDOM }\n  },\n\n  // :: NodeSpec A horizontal rule (`<hr>`).\n  horizontal_rule: {\n    group: \"block\",\n    parseDOM: [{tag: \"hr\"}],\n    toDOM() { return hrDOM }\n  },\n\n  // :: NodeSpec A heading textblock, with a `level` attribute that\n  // should hold the number 1 to 6. Parsed and serialized as `<h1>` to\n  // `<h6>` elements.\n  heading: {\n    attrs: {level: {default: 1}},\n    content: \"inline*\",\n    group: \"block\",\n    defining: true,\n    parseDOM: [{tag: \"h1\", attrs: {level: 1}},\n               {tag: \"h2\", attrs: {level: 2}},\n               {tag: \"h3\", attrs: {level: 3}},\n               {tag: \"h4\", attrs: {level: 4}},\n               {tag: \"h5\", attrs: {level: 5}},\n               {tag: \"h6\", attrs: {level: 6}}],\n    toDOM(node) { return [\"h\" + node.attrs.level, 0] }\n  },\n\n  // :: NodeSpec A code listing. Disallows marks or non-text inline\n  // nodes by default. Represented as a `<pre>` element with a\n  // `<code>` element inside of it.\n  code_block: {\n    content: \"text*\",\n    marks: \"\",\n    group: \"block\",\n    code: true,\n    defining: true,\n    parseDOM: [{tag: \"pre\", preserveWhitespace: \"full\"}],\n    toDOM() { return preDOM }\n  },\n\n  // :: NodeSpec The text node.\n  text: {\n    group: \"inline\"\n  },\n\n  // :: NodeSpec An inline image (`<img>`) node. Supports `src`,\n  // `alt`, and `href` attributes. The latter two default to the empty\n  // string.\n  image: {\n    inline: true,\n    attrs: {\n      src: {},\n      alt: {default: null},\n      title: {default: null}\n    },\n    group: \"inline\",\n    draggable: true,\n    parseDOM: [{tag: \"img[src]\", getAttrs(dom) {\n      return {\n        src: dom.getAttribute(\"src\"),\n        title: dom.getAttribute(\"title\"),\n        alt: dom.getAttribute(\"alt\")\n      }\n    }}],\n    toDOM(node) { let {src, alt, title} = node.attrs; return [\"img\", {src, alt, title}] }\n  },\n\n  // :: NodeSpec A hard line break, represented in the DOM as `<br>`.\n  hard_break: {\n    inline: true,\n    group: \"inline\",\n    selectable: false,\n    parseDOM: [{tag: \"br\"}],\n    toDOM() { return brDOM }\n  }\n}\n\nconst emDOM = [\"em\", 0], strongDOM = [\"strong\", 0], codeDOM = [\"code\", 0]\n\n// :: Object [Specs](#model.MarkSpec) for the marks in the schema.\nexport const marks = {\n  // :: MarkSpec A link. Has `href` and `title` attributes. `title`\n  // defaults to the empty string. Rendered and parsed as an `<a>`\n  // element.\n  link: {\n    attrs: {\n      href: {},\n      title: {default: null}\n    },\n    inclusive: false,\n    parseDOM: [{tag: \"a[href]\", getAttrs(dom) {\n      return {href: dom.getAttribute(\"href\"), title: dom.getAttribute(\"title\")}\n    }}],\n    toDOM(node) { let {href, title} = node.attrs; return [\"a\", {href, title}, 0] }\n  },\n\n  // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.\n  // Has parse rules that also match `<i>` and `font-style: italic`.\n  em: {\n    parseDOM: [{tag: \"i\"}, {tag: \"em\"}, {style: \"font-style=italic\"}],\n    toDOM() { return emDOM }\n  },\n\n  // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules\n  // also match `<b>` and `font-weight: bold`.\n  strong: {\n    parseDOM: [{tag: \"strong\"},\n               // This works around a Google Docs misbehavior where\n               // pasted content will be inexplicably wrapped in `<b>`\n               // tags with a font-weight normal.\n               {tag: \"b\", getAttrs: node => node.style.fontWeight != \"normal\" && null},\n               {style: \"font-weight\", getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null}],\n    toDOM() { return strongDOM }\n  },\n\n  // :: MarkSpec Code font mark. Represented as a `<code>` element.\n  code: {\n    parseDOM: [{tag: \"code\"}],\n    toDOM() { return codeDOM }\n  }\n}\n\n// :: Schema\n// This schema roughly corresponds to the document schema used by\n// [CommonMark](http://commonmark.org/), minus the list elements,\n// which are defined in the [`prosemirror-schema-list`](#schema-list)\n// module.\n//\n// To reuse elements from this schema, extend or read from its\n// `spec.nodes` and `spec.marks` [properties](#model.Schema.spec).\nexport const schema = new Schema({nodes, marks})\n"]},"metadata":{},"sourceType":"module"}